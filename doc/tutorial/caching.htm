<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
	<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
	<title>Caching Of Values and Reusing Computations - Abacus Formula Compiler for Java</title>
    <style type="text/css" media="screen">
		
    </style>
	<link href="../../style_screen.css" rel="stylesheet" type="text/css" media="screen" /><link href="../../style_print.css" rel="stylesheet" type="text/css" media="print" />
</head>

<body>
	<div id="outer">
		<div id="left_background">
		</div>
		<div id="top_background">
		</div>
		
		<div class="chrome" id="top_chrome">
			<div id="logo_band">
				<img src="../../site_img/header_bar.gif" alt="AFC - Abacus Formula Compiler for Java" />
			</div>
			<div id="download_band">
				<a href="../../download/index.htm">
					<img src="../../site_img/download_button.gif" />
				</a>
			</div>
			<div id="area_band">
				<table height="100%"><tr height="100%"><td style="vertical-align:middle">
						
					<a href="../../index.htm">Home</a> | 
						
					<a href="../../quick.htm">Quick Start</a> | <span class="selected"><a href="../../doc/index.htm">Documentation</a></span> | <a href="../../download/index.htm">Download</a> | <a href="../../support.htm">Support</a> | <a href="../../contribute/index.htm">Contribute</a>
				</td></tr></table>
			</div>
		</div>

		<div id="inner">
			<div class="chrome" id="inner_top_chrome">
				<div id="crumbs_band">
					<a href="../../index.htm">Home</a> &gt; <a href="../index.htm">Documentation</a> &gt; <a href="index.htm">Tutorial</a> &gt; 
				</div>
			</div>

			<div class="content" id="content">

<h1>Caching Of Values and Reusing Computations</h1>

	<p>Many computations can be sped up by turning on internal caching of cell values. And some functions (<code>NOW</code> and <code>MATCH</code>, for example), or repeating sections, <em>always</em> use internal caches. Caches, however, introduce state. You need to reset this state when reusing computations on modified inputs.</p>



	<h2><a name="pagetoc__1">Why Cache?</a></h2>

	<p>Consider the following very simple example spreadsheet doing the computation of a square&#8217;s area and a cube&#8217;s volume, given the side length. The cell B1 is the sole input, B3 and B4 are outputs.</p>

	<table class="xl">
	<thead>
		<tr>
			<td/>
			<td>A</td>
			<td>B</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="xl-row">1</td>
			<td>Side</td>
			<td class="xl-num">2</td>
		</tr>
		<tr>
			<td class="xl-row">2</td>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td class="xl-row">3</td>
			<td>Area</td>
			<td class="xl-num">4<br/><span class="xl-exp">=B1*B1</span></td>
		</tr>
		<tr>
			<td class="xl-row">4</td>
			<td>Volume</td>
			<td class="xl-num">8<br/><span class="xl-exp">=B3*B1</span></td>
		</tr>
	</tbody>
</table>



	<p>Turning on internal caching would give us the following benefits.</p>


<dl>
<dt>Intermediate Values</dt><dd>The <em>area</em> is reused by the <em>volume</em> computation. Even in this simple example, if you compute millions of areas and volumes using <code>BigDecimal</code> and side lengths of great precision, the cache pays off.</dd>

<dt>Input Values</dt><dd>The input <em>side length</em> is used three times in all. Assuming it is expensive to obtain (maybe it involves a database access), the cache will also pay off. You could, of course, cache this value yourself. But since <span class="caps">AFC</span> supports automatic internal caching anyway, you can save yourself the trouble.</dd>

<dt>Output Values</dt><dd>Finally, <span class="caps">AFC</span> also caches output values. So if you access them multiple times, you benefit without having to cache them yourself.</dd>
</dl>

	<h5>Note</h5>

	<p>Caching of input and output values also encourages a functional view of computations, i.e. input value accessors that have no side effects. Since you cannot know beforehand how many times a spreadsheet will access your input values, having side effects in them is very likely a bad idea.</p>


	<h2><a name="pagetoc__2">No Caching Is Standard</a></h2>

	<p>Normally, computations generated by <span class="caps">AFC</span> do not cache values internally, except for some special functions. The reason is that the overhead introduced by caching is not warranted for simple, straightforward computations. Here is an example of this, where we count the number of accesses to the input, the <em>side length</em>:</p>

	<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
Output output = <span class="j-sym">(</span>Output<span class="j-sym">) </span>factory.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">0</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;
output.<span class="j-hl">getArea<span class="j-sym">()</span></span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">2</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;
output.<span class="j-hl">getVolume<span class="j-sym">()</span></span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">5</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;</pre>


	<h5>Note</h5>

	<p>This stateless behaviour is not guaranteed. <span class="caps">AFC</span> <em>always</em> caches repeating sections, and certain functions. <code>NOW</code>, for example, is required to return the same value for the entire duration of a computation, so <span class="caps">AFC</span> caches the value returned on the first invocation. See further below for details.</p>


	<h2><a name="pagetoc__3">Turning On Caching</a></h2>

	<p>Let&#8217;s now turn on explicit, full caching:</p>

	<pre class="java">EngineBuilder builder = SpreadsheetCompiler.newEngineBuilder<span class="j-sym">()</span>;
builder.loadSpreadsheet<span class="j-sym">( </span>path <span class="j-sym">)</span>;
builder.setInputClass<span class="j-sym">( </span>Input.<span class="j-key">class </span><span class="j-sym">)</span>;
builder.setOutputClass<span class="j-sym">( </span>Output.<span class="j-key">class </span><span class="j-sym">)</span>;
builder.setNumericType<span class="j-sym">( </span>unboundedBigDecimal <span class="j-sym">)</span>;
<span class="j-hl">builder.setFullCaching<span class="j-sym">( </span><span class="j-key">true </span><span class="j-sym">)</span>;</span>
builder.bindAllByName<span class="j-sym">()</span>;
SaveableEngine engine = builder.compile<span class="j-sym">()</span>;</pre>


	<p>Here&#8217;s what happens if we run the above example again, but with caching enabled:</p>

	<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
Output output = <span class="j-sym">(</span>Output<span class="j-sym">) </span>factory.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">0</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;
output.<span class="j-hl">getArea<span class="j-sym">()</span></span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">1</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;
output.<span class="j-hl">getVolume<span class="j-sym">()</span></span>;
assertEquals<span class="j-sym">( </span><span class="j-hl">1</span>, input.getNumberOfAccessesToSide<span class="j-sym">() )</span>;</pre>


	<p>The input is only accessed once.</p>


	<h5>Was it worth it?</h5>

	<p>In this example, does caching pay off? Let&#8217;s compare the speed of computing the area and volume with and without caching for a largish value of <em>side</em>:</p>

	<pre class="java"><span class="j-typ">long </span>startTime = System.nanoTime<span class="j-sym">()</span>;
output.getArea<span class="j-sym">()</span>;
output.getVolume<span class="j-sym">()</span>;
<span class="j-typ">long </span>timeTaken = System.nanoTime<span class="j-sym">() </span>- startTime;</pre>


	<p>We find that caching is faster by more than than half:</p>

	<pre class="java">input.setSide<span class="j-sym">( </span><span class="j-str">&#34;123456789123456789123456789123456789123456789123456789123456789123456789&#34; </span><span class="j-sym">)</span>;
<span class="j-typ">long </span>plainTime = time<span class="j-sym">( </span>plainFactory, input <span class="j-sym">)</span>;
<span class="j-typ">long </span>cachingTime = time<span class="j-sym">( </span>cachingFactory, input <span class="j-sym">)</span>;
assertTrue<span class="j-sym">( </span><span class="j-str">&#34;Caching is at least half as fast again; caching is &#34; </span>+ cachingTime + <span class="j-str">&#34; vs. &#34; </span>+ plainTime,
    cachingTime * <span class="j-num">3 </span>/ <span class="j-num">2 </span>&lt; plainTime <span class="j-sym">)</span>;</pre>


	<h2><a name="reuse">Reusing Computations</a></h2>

	<p>As I said before, computations generated by <span class="caps">AFC</span> do not normally cache values internally, unless you explicitly turn on caching. This might lead you to believe that a computation behaves correctly when you call it multiple times while, in between, modifying the data returned by its input object. Here is an example of this:</p>

	<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
Output output = <span class="j-sym">(</span>Output<span class="j-sym">) </span>factory.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;

input.setSide<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;10&#34;</span></span> <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;100&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;1000&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;

input.setSide<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;5&#34;</span></span> <span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;25&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;125&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>


	<p>This is not guaranteed, however! <span class="caps">AFC</span> makes no promise to not cache internally. And what works now might not work in a future release of <span class="caps">AFC</span>. (In fact, for functions like <code>NOW</code> it always has to cache, because <code>NOW</code> is required to return the same value for the duration of a single computation.) And what about reusing computations where we <em>do</em> turn on caching? Here&#8217;s what happens if we run the above example again, with internal caching:</p>

	<pre class="java">Input input = <span class="j-key">new </span>Input<span class="j-sym">()</span>;
Output output = <span class="j-sym">(</span>Output<span class="j-sym">) </span>factory.newComputation<span class="j-sym">( </span>input <span class="j-sym">)</span>;

input.setSide<span class="j-sym">( </span><span class="j-str">&#34;10&#34; </span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;100&#34;</span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;1000&#34;</span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;

input.setSide<span class="j-sym">( </span><span class="j-str">&#34;5&#34; </span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;100&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;1000&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>


	<p>Note how changing the input value does <strong>not</strong> affect the output values. The are still cached from the previous use.</p>


	<h5><code>reset()</code></h5>

	<p>We have to be able to <em>reset</em> a computation when we have modified its input. <span class="caps">AFC</span> supports this if our output interface or class implements the <code>Resettable</code> interface:</p>

	<pre class="java"><span class="j-jdoc">/**
 * Interface that must be implemented by an output class (or extended by an output interface) of
 * computations that need to reset internal caches of values - typically for reuse on modified input
 * values.
 * 
 * </span><span class="j-jdoc-key">@author </span><span class="j-jdoc">peo
 */
</span><span class="j-key">public interface </span>Resettable
<span class="j-sym">{

  </span><span class="j-jdoc">/**
   * Clears all internal caches of the computation so it can be reused with changed input values.
   * You do not need to implement this method yourself. As long as you declare it, AFC will
   * implement it for you. If you do implement it, AFC will call it prior to resetting the
   * computation.
   */
  </span><span class="j-typ">void </span>reset<span class="j-sym">()</span>;

<span class="j-sym">}</span></pre>


	<p>It does:</p>

	<pre class="java"><span class="j-key">public static interface </span>Output <span class="j-hl">extends Resettable</span>
<span class="j-sym">{
  </span>BigDecimal getArea<span class="j-sym">()</span>;
  BigDecimal getVolume<span class="j-sym">()</span>;
<span class="j-sym">}</span></pre>


	<p>so let&#8217;s do this properly:</p>

	<pre class="java">input.setSide<span class="j-sym">( </span><span class="j-str">&#34;10&#34; </span><span class="j-sym">)</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;100&#34;</span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-str">&#34;1000&#34;</span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;

input.setSide<span class="j-sym">( </span><span class="j-str">&#34;5&#34; </span><span class="j-sym">)</span>;
<span class="j-hl">output.reset<span class="j-sym">()</span>;</span>
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;25&#34;</span></span>, output.getArea<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;
assertEquals<span class="j-sym">( </span><span class="j-hl"><span class="j-str">&#34;125&#34;</span></span>, output.getVolume<span class="j-sym">()</span>.toPlainString<span class="j-sym">() )</span>;</pre>


	<h2><a name="pagetoc__5">Caching Internals</a></h2>

	<h5>Non-caching</h5>

	<p>The generated non-caching computation is:</p>

	<pre class="java"><span class="j-key">package </span>org.formulacompiler.gen;
<span class="j-key">import </span>java.math.BigDecimal;

<span class="j-key">import </span>org.formulacompiler.runtime.Computation;
<span class="j-key">import </span>org.formulacompiler.runtime.internal.Environment;
<span class="j-key">import </span>org.formulacompiler.runtime.internal.RuntimeBigDecimal_v2;
<span class="j-key">import </span>org.formulacompiler.tutorials.Caching;

<span class="j-key">final class </span>$Root <span class="j-key">implements </span>Computation, Caching.Output
<span class="j-sym">{
    </span><span class="j-key">private final </span>Caching.Input $inputs;
    <span class="j-key">final </span>Environment $environment;
    
    $Root<span class="j-sym">(</span>Caching.Input input, Environment environment<span class="j-sym">) {
        </span>$environment = environment;
        $inputs = input;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span><span class="j-typ">void </span>reset<span class="j-sym">() {
        </span><span class="j-blk">/* empty */
    </span><span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$0<span class="j-sym">() {
        </span><span class="j-key">return </span>get$1<span class="j-sym">()</span>.multiply<span class="j-sym">(</span>get$1<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span>BigDecimal getArea<span class="j-sym">() {
        </span><span class="j-key">return </span>get$0<span class="j-sym">()</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$1<span class="j-sym">() {
        </span><span class="j-key">return </span>RuntimeBigDecimal_v2.toNum<span class="j-sym">(</span>$inputs.getSide<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$2<span class="j-sym">() {
        </span><span class="j-key">return </span>get$0<span class="j-sym">()</span>.multiply<span class="j-sym">(</span>get$1<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span>BigDecimal getVolume<span class="j-sym">() {
        </span><span class="j-key">return </span>get$2<span class="j-sym">()</span>;
    <span class="j-sym">}
}</span></pre>


	<h5>Caching</h5>

	<p>With caching, it is:</p>

	<pre class="java"><span class="j-key">package </span>org.formulacompiler.gen;
<span class="j-key">import </span>java.math.BigDecimal;

<span class="j-key">import </span>org.formulacompiler.runtime.Computation;
<span class="j-key">import </span>org.formulacompiler.runtime.internal.Environment;
<span class="j-key">import </span>org.formulacompiler.runtime.internal.RuntimeBigDecimal_v2;
<span class="j-key">import </span>org.formulacompiler.tutorials.Caching;

<span class="j-key">final class </span>$Root <span class="j-key">implements </span>Computation, Caching.Output
<span class="j-sym">{
    </span><span class="j-key">private final </span>Caching.Input $inputs;
    <span class="j-key">final </span>Environment $environment;
    <span class="j-key">private </span><span class="j-typ">boolean </span>h$get$0;
    <span class="j-key">private </span>BigDecimal c$get$0;
    <span class="j-key">private </span><span class="j-typ">boolean </span>h$get$1;
    <span class="j-key">private </span>BigDecimal c$get$1;
    <span class="j-key">private </span><span class="j-typ">boolean </span>h$get$2;
    <span class="j-key">private </span>BigDecimal c$get$2;
    
    $Root<span class="j-sym">(</span>Caching.Input input, Environment environment<span class="j-sym">) {
        </span>$environment = environment;
        $inputs = input;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span><span class="j-typ">void </span>reset<span class="j-sym">() {
        </span>h$get$0 = <span class="j-key">false</span>;
        h$get$1 = <span class="j-key">false</span>;
        h$get$2 = <span class="j-key">false</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$0<span class="j-sym">() {
        </span><span class="j-key">if </span><span class="j-sym">(</span>!h$get$0<span class="j-sym">) {
            </span>c$get$0 = get$1<span class="j-sym">()</span>.multiply<span class="j-sym">(</span>get$1<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
            h$get$0 = <span class="j-key">true</span>;
        <span class="j-sym">}
        </span><span class="j-key">return </span>c$get$0;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span>BigDecimal getArea<span class="j-sym">() {
        </span><span class="j-key">return </span>get$0<span class="j-sym">()</span>;
    <span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$1<span class="j-sym">() {
        </span><span class="j-key">if </span><span class="j-sym">(</span>!h$get$1<span class="j-sym">) {
            </span>c$get$1
                = RuntimeBigDecimal_v2.toNum<span class="j-sym">(</span>$inputs.getSide<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
            h$get$1 = <span class="j-key">true</span>;
        <span class="j-sym">}
        </span><span class="j-key">return </span>c$get$1;
    <span class="j-sym">}
    
    </span><span class="j-key">final </span>BigDecimal get$2<span class="j-sym">() {
        </span><span class="j-key">if </span><span class="j-sym">(</span>!h$get$2<span class="j-sym">) {
            </span>c$get$2 = get$0<span class="j-sym">()</span>.multiply<span class="j-sym">(</span>get$1<span class="j-sym">())</span>.setScale<span class="j-sym">(</span><span class="j-num">0</span>, <span class="j-num">4</span><span class="j-sym">)</span>;
            h$get$2 = <span class="j-key">true</span>;
        <span class="j-sym">}
        </span><span class="j-key">return </span>c$get$2;
    <span class="j-sym">}
    
    </span><span class="j-key">public final </span>BigDecimal getVolume<span class="j-sym">() {
        </span><span class="j-key">return </span>get$2<span class="j-sym">()</span>;
    <span class="j-sym">}
}</span></pre>


	<p>Clearly, this is a lot more code than for the non-caching version. It is important to realize, however, that <span class="caps">AFC</span> only caches intermediate cell values which are referenced more than once in the computation. All others are inlined into the single expression that references them. Cells that are not referenced at all don&#8217;t appear in the computation at all, either.</p>

			</div>
			<div class="chrome" id="inner_bottom_chrome">
			</div>
		</div>
		
		
		
		<div class="chrome" id="left_top_chrome">
			<div id="area_toc"><div class="area"><a href="../../doc/design.htm">Design Overview</a></div>
<div class="area"><span class="selected"><a href="../../doc/tutorial/index.htm">Tutorial</a></span></div>
<div class="nested">
<div class="area"><span class="selected">Caching Of Values and Reusing Computations</span></div>
<div id="page_toc"><div class="toc"><ul class="toc toc1"><li><a href="#pagetoc__1">Why Cache?</a></li><li><a href="#pagetoc__2">No Caching Is Standard</a></li><li><a href="#pagetoc__3">Turning On Caching</a></li><li><a href="#reuse">Reusing Computations</a></li><li><a href="#pagetoc__5">Caching Internals</a></li></ul></div></div>
</div>
<div class="area"><a href="../../doc/reference/index.htm">Function Reference</a></div>
<div class="area"><a href="../../doc/javadoc/index.htm">API Reference</a></div>
<div class="area"><a href="../../doc/examples/index.htm">Sample Applications</a></div>
<div class="area"><a href="../../doc/impl/index.htm">Implementation Details</a></div>
<div class="area"><a href="../../doc/limitations.htm">Limitations</a></div></div>
		</div>
		</div>
		<div class="chrome" id="left_bottom_chrome">
			<div id="copyright">
				Copyright &copy; 2005-2008 by <a href="http://www.abacus.ch/">Abacus Research AG</a>.  All rights reserved.
			</div>
		</div>
	
</body>
</html>
